<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - basis texture loader</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
	</head>
	<body>

		<div id="info">
			<a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> - webgl - basis texture loader<br />
			<a href="https://github.com/binomialLLC/basis_universal" target="_blank">Basis Universal GPU Texture Codec</a>
		</div>

		<script id="vertexShader" type="x-shader/x-vertex">
			varying vec2 vUv;
			uniform float iTime;
		
			void main() {
				vUv = uv;
		
				gl_Position =   projectionMatrix * 
								modelViewMatrix * 
								vec4(position,1.0);
			}
		</script>
		
		<script id="fragmentShader" type="x-shader/x-fragment">
			uniform sampler2D texture1;
			uniform sampler2D texture2;
			uniform float iTime;
		
			varying vec2 vUv;
		
			void main() {
				vec2 modUv = mod(vUv + iTime * 0.3, 1.0);
				vec4 color = texture2D(texture1, modUv);
				vec4 maskColor = texture2D(texture2, vUv);

				float alpha = maskColor.r;
				/*
				float alpha = 1.0 - step(0.5, color.r);
				gl_FragColor = vec4(color.r, color.g, color.b, color.a * alpha);
				*/
				gl_FragColor = vec4(color.r, color.g, color.b, alpha);
			}
		</script>

		<script type="module">

			import * as THREE from '../build/three.module.js';

			import { BasisTextureLoader } from './jsm/loaders/BasisTextureLoader.js';
			import { GLTFLoader } from './jsm/loaders/GLTFLoader.js';
			import { OrbitControls } from './jsm/controls/OrbitControls.js';

			var camera, scene, renderer;
			var mesh;

			var clock = new THREE.Clock();
			var thing, vertShader, fragShader;
			var uniforms, colorTexture, maskTexture;
			var textureOffset = 0;
			var controls;
			

			init();
			animate();

			function init() {

				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.gammaOutput = true;
				renderer.gammaFactor = 2.2;
				document.body.appendChild( renderer.domElement );
				vertShader = document.getElementById('vertexShader').innerHTML;
				fragShader = document.getElementById('fragmentShader').innerHTML;

				
				
				camera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 1, 2000 );
				
				
				scene = new THREE.Scene();
				
				//loadGltfModel();
				
				makePlane();
				
				
				window.addEventListener( 'resize', onWindowResize, false );
				controls = new OrbitControls( camera, renderer.domElement );

			}

			function makePlane() {
				

				var geometry = new THREE.PlaneBufferGeometry( 20, 20, 8, 8 );
				// var material = new THREE.MeshBasicMaterial( {
				// 	color: 0xff0000, 
				// 	side: THREE.DoubleSide,
				// 	wireframe: true
				// } );
				var material = new THREE.MeshNormalMaterial();
				thing = new THREE.Mesh( geometry, material );
				scene.add( thing );
				scene.position.set(0, 0, -40);
				console.log(thing);

				
				let positions = thing.geometry.attributes.position.array;
				for(let i = 0; i < positions.length; i+=5) {
					positions[i] += Math.random() * 4 - 2;
				}
				
				
				geometry.computeVertexNormals();
				geometry.computeFaceNormals();
				
				geometry.verticesNeedUpdate = true;
				geometry.normalsNeedUpdate = true;
				geometry.uvsNeedUpdate = true;

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function animate(time) {
				controls.update();
				time *= 0.001;

				requestAnimationFrame( animate );

				var delta = clock.getDelta() * 0.5;

				if(thing) {
					

				}

				renderer.render( scene, camera );
			}

			function loadGltfModel() {
				var loader = new GLTFLoader();
				var modelName = "models/gltf/CloudTest_01.gltf";

				loader.load( modelName, function ( gltf ) {

					gltf.scene.traverse(item => {
						if(item.name === 'Thin_CloudLayer') {
							thing = item;
						}
					});

					colorTexture = THREE.ImageUtils.loadTexture( "textures/CloudTestTex_01.jpg" );
					
					maskTexture = THREE.ImageUtils.loadTexture( "textures/CloudTestMask_01.jpg" );

					uniforms = {	
						texture1: { 
							type: "t", 
							value: colorTexture
						},
						texture2: {
							type: "t",
							value: maskTexture
						},
						iTime: { 
							value: 0 
						},
					};
	
					var material = new THREE.ShaderMaterial({
						uniforms: uniforms,
						vertexShader: vertShader,
						fragmentShader: fragShader,
						side: THREE.DoubleSide,
						transparent: true
					});

					thing.add(new THREE.AxesHelper(20000));
					//debugger;

					thing.material = material;
					console.log('thing:  ', thing);
					scene.add(thing);

					camera.position.z = 30;
					camera.position.y += 20
					camera.lookAt(thing.position);
				

				} );


			}

		</script>

	</body>
</html>
