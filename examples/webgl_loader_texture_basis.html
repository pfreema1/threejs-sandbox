<!DOCTYPE html>
<html lang="en">

<head>
	<title>three.js webgl - basis texture loader</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<link type="text/css" rel="stylesheet" href="main.css">
</head>

<body>


	<script id="bgVertShader" type="x-shader/x-vertex">
			uniform float iTime;
			varying vec2 vUv;
			varying vec3 vNormal;
		
			void main() {
				vUv = uv;
				vNormal = normal;
		
				gl_Position =   projectionMatrix * 
								modelViewMatrix * 
								vec4(position,1.0);
			}
		</script>

	<script id="bgFragShader" type="x-shader/x-fragment">
			uniform float iTime;
			uniform sampler2D texture1;
		
			varying vec2 vUv;
			varying mediump vec3 vNormal;
		
			void main() {
				mediump vec3 light = vec3(0.0, 0.0, 1.0);
				vec2 uv = vUv;

				// ensure it's normalized
				light = normalize(light);

				
				// calculate the dot product of
				// the light to the vertex normal
				mediump float dProd = max(0.0, dot(vNormal, light));

				vec3 refractVec1 = refract(light, vNormal, 0.2);
				vec3 refractVec2 = refract(vec3(0.2, 0.0, 1.0), vNormal, 0.2);
				vec3 refractVec3 = refract(vec3(0.4, 0.0, 1.0), vNormal, 0.2);

				vec4 color1 = texture2D(texture1, uv + refractVec1.xy * 0.5);
				vec4 color2 = texture2D(texture1, uv + refractVec2.xy * 0.5);
				vec4 color3 = texture2D(texture1, uv + refractVec3.xy * 0.5);

				// attenuate color intensity based on light angle
				// color1 *= dProd;
				// color2 *= dProd;
				// color3 *= dProd;

				//vec3 finalColor = vec3(color1.r, color2.g, color3.b);
				vec3 finalColor = texture2D(texture1, uv).rgb;

				gl_FragColor = vec4(finalColor, 1.0);
			}
		</script>

	<script id="quadVertShader" type="x-shader/x-vertex">
			uniform float iTime;
			varying vec2 vUv;
			varying vec3 vNormal;
		
			void main() {
				vUv = uv;
				vNormal = normal;

				//gl_Position = vec4(position, 1.0);
		
				
				gl_Position =   projectionMatrix * 
								modelViewMatrix * 
								vec4(position,1.0);
				
			}
		</script>

	<script id="quadFragShader" type="x-shader/x-fragment">
			uniform float iTime;
			uniform sampler2D bgTexture;
			uniform sampler2D distortionTexture;
		
			varying vec2 vUv;
		
			void main() {
				vec4 bgColor = texture2D(bgTexture, vUv);
				vec4 normalColor = texture2D(distortionTexture, vUv);
				vec3 normal = normalize(normalColor.rgb * 2.0 - 1.0);
				
				vec3 refractVec1 = refract(vec3(0.0, 0.0, 1.0), normal, 0.2);
				vec3 refractVec2 = refract(vec3(0.2, 0.0, 1.0), normal, 0.2);
				vec3 refractVec3 = refract(vec3(0.2, 0.0, 1.0), normal, 0.2);
				vec4 refractColor1 = texture2D(bgTexture, vUv + refractVec1.xy * 0.3);
				vec4 refractColor2 = texture2D(bgTexture, vUv + refractVec2.xy * 0.3);
				vec4 refractColor3 = texture2D(bgTexture, vUv + refractVec3.xy * 0.3);

				vec4 refractColor = vec4(refractColor1.r, refractColor2.g, refractColor3.b, 1.0);

				// normalColor.a determines if we need to use the refracted colors or not
				vec4 color =  bgColor + refractColor * normalColor.a;


				gl_FragColor = vec4(color);
			}
		</script>

	<script type="module">

		import * as THREE from '../build/three.module.js';

		import { BasisTextureLoader } from './jsm/loaders/BasisTextureLoader.js';
		import { GLTFLoader } from './jsm/loaders/GLTFLoader.js';
		import { OrbitControls } from './jsm/controls/OrbitControls.js';

		var camera, scene, renderer;
		var mesh;

		var clock = new THREE.Clock();
		var thing, bgVertShader, bgFragShader, quadVertShader, quadFragShader;
		var uniforms, colorTexture, maskTexture;
		var textureOffset = 0;
		var controls;
		var bgUniforms, bgTexture, bgMesh, bgRenderTarget, bgRtCamera, bgRtScene;
		var distortionScene, distortionCamera, distortionRenderTarget;
		var fsQuad, fsQuadUniforms;


		init();
		animate();

		function init() {

			renderer = new THREE.WebGLRenderer({ antialias: true });
			renderer.setPixelRatio(window.devicePixelRatio);
			renderer.setSize(window.innerWidth, window.innerHeight);
			renderer.gammaOutput = true;
			renderer.gammaFactor = 2.2;
			document.body.appendChild(renderer.domElement);
			bgVertShader = document.getElementById('bgVertShader').innerHTML;
			bgFragShader = document.getElementById('bgFragShader').innerHTML;
			quadVertShader = document.getElementById('quadVertShader').innerHTML;
			quadFragShader = document.getElementById('quadFragShader').innerHTML;

			bgRenderTarget = new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight);
			bgRtCamera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 2000);
			bgRtCamera.position.set(0, 0, 5);

			distortionRenderTarget = new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight);
			distortionCamera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 2000);
			distortionCamera.position.set(0, 0, 5);


			camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 2000);
			camera.position.set(0, 0, 5);



			scene = new THREE.Scene();
			bgRtScene = new THREE.Scene();
			distortionScene = new THREE.Scene();


			//loadGltfModel();
			makeBackgroundPlane();

			makeDistortionPlane();


			makeFsQuad();


			window.addEventListener('resize', onWindowResize, false);

		}

		function makeFsQuad() {

			let geo = new THREE.PlaneGeometry(2, 2);

			fsQuadUniforms = {
				iTime: {
					value: 0
				},
				bgTexture: {
					type: "t",
					value: bgRenderTarget.texture
				},
				distortionTexture: {
					type: "t",
					value: distortionRenderTarget.texture
				}
			};

			let material = new THREE.ShaderMaterial({
				vertexShader: quadVertShader,
				fragmentShader: quadFragShader,
				uniforms: fsQuadUniforms
				// depthWrite: false,
				// depthTest: false
			});

			fsQuad = new THREE.Mesh(geo, material);

			scene.add(fsQuad);
		}

		function makeBackgroundPlane() {
			bgTexture = THREE.ImageUtils.loadTexture("textures/allyouseeis.png");

			var geometry = new THREE.PlaneBufferGeometry(20, 20, 8, 8);

			bgUniforms = {
				iTime: {
					value: 0
				},
				texture1: {
					type: "t",
					value: bgTexture
				},
			};

			var material = new THREE.ShaderMaterial({
				uniforms: bgUniforms,
				vertexShader: bgVertShader,
				fragmentShader: bgFragShader,
				side: THREE.DoubleSide,
				transparent: true
			});

			bgMesh = new THREE.Mesh(geometry, material);
			bgMesh.name = 'bgMesh';
			bgMesh.position.set(0, 0, -20);
			bgMesh.scale.set(1, 1, 1);
			// scene.add(bgMesh);
			bgRtScene.add(bgMesh);
			console.log(bgRtScene);

		}

		function makeDistortionPlane() {

			var geometry = new THREE.PlaneBufferGeometry(20, 20, 8, 8);

			var material = new THREE.MeshNormalMaterial();
			// var material = new THREE.MeshStandardMaterial();

			thing = new THREE.Mesh(geometry, material);
			thing.position.set(0, 0, -20);
			// scene.add(thing);
			distortionScene.add(thing);

			// offset vertices
			let positions = thing.geometry.attributes.position.array;
			for (let i = 0; i < positions.length; i += 5) {
				positions[i] += Math.random() * 2 - 1;
			}


			geometry.computeVertexNormals();
			geometry.computeFaceNormals();

			geometry.verticesNeedUpdate = true;
			geometry.normalsNeedUpdate = true;
			geometry.uvsNeedUpdate = true;

			material.needsUpdate = true;



		}

		function onWindowResize() {

			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();

			renderer.setSize(window.innerWidth, window.innerHeight);

		}





		function animate(time) {

			time *= 0.001;

			requestAnimationFrame(animate);

			var delta = clock.getDelta() * 0.5;

			if (thing) {
				thing.rotation.y = 0.3 * Math.sin(time);
			}

			renderer.setRenderTarget(bgRenderTarget);
			renderer.render(bgRtScene, bgRtCamera);
			renderer.setRenderTarget(distortionRenderTarget);
			renderer.render(distortionScene, distortionCamera);
			renderer.setRenderTarget(null);

			renderer.render(scene, camera);

		}



	</script>

</body>

</html>
