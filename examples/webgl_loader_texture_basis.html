<!DOCTYPE html>
<html lang="en">

<head>
	<title>three.js webgl - basis texture loader</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<link type="text/css" rel="stylesheet" href="main.css">
</head>

<body>
	<script id="distPlaneEdgesVertShader" type="x-shader/x-vertex">
		varying vec2 vUv;
		varying vec3 vBC;

		attribute vec3 barycentric;
	
		void main() {
			vUv = uv;
			vBC = barycentric;
	
			gl_Position =   projectionMatrix * 
							modelViewMatrix * 
							vec4(position,1.0);
		}
	</script>

	<script id="distPlaneEdgesFragShader" type="x-shader/x-fragment">
		varying vec2 vUv;
		varying vec3 vBC;
	
		void main() {
			float color = pow(distance(vec3(0.33), vBC), 3.0);
			vec3 white = vec3(1.0, 1.0, 1.0);
			// x * y * z = 0 if any of the components is 0
			float line = 1.0 - smoothstep(0.0, 0.005, vBC.x * vBC.y * vBC.z);
			vec3 finalColor = mix(vec3(color), white, line);
			gl_FragColor = vec4(finalColor, 1.0);
		}
	</script>

	<script id="distPlaneNormalsVertShader" type="x-shader/x-vertex">
		varying vec2 vUv;
		varying vec3 vNormal;
		varying vec3 vBC;

	
		void main() {
			vUv = uv;
			vNormal = normalMatrix * normalize(normal);
	
			gl_Position =   projectionMatrix * 
							modelViewMatrix * 
							vec4(position,1.0);
		}
	</script>

	<script id="distPlaneNormalsFragShader" type="x-shader/x-fragment">
		varying vec2 vUv;
		varying mediump vec3 vNormal;
	
		void main() {
			vec3 view_nv = normalize(vNormal);
			vec3 nv_color = view_nv * 0.5 + 0.5;
			
			gl_FragColor = vec4(nv_color, 1.0);
		}
	</script>


	<script id="bgVertShader" type="x-shader/x-vertex">
		uniform float iTime;
		varying vec2 vUv;
		varying vec3 vNormal;
	
		void main() {
			vUv = uv;
			vNormal = normal;
	
			gl_Position =   projectionMatrix * 
							modelViewMatrix * 
							vec4(position,1.0);
		}
	</script>

	<script id="bgFragShader" type="x-shader/x-fragment">
		uniform float iTime;
		uniform sampler2D texture1;
	
		varying vec2 vUv;
		varying mediump vec3 vNormal;
	
		void main() {
			mediump vec3 light = vec3(0.0, 0.0, 1.0);
			vec2 uv = vUv;

			// ensure it's normalized
			light = normalize(light);

			
			// calculate the dot product of
			// the light to the vertex normal
			mediump float dProd = max(0.0, dot(vNormal, light));

			vec3 refractVec1 = refract(light, vNormal, 0.2);
			vec3 refractVec2 = refract(vec3(0.2, 0.0, 1.0), vNormal, 0.2);
			vec3 refractVec3 = refract(vec3(0.4, 0.0, 1.0), vNormal, 0.2);

			vec4 color1 = texture2D(texture1, uv + refractVec1.xy * 0.5);
			vec4 color2 = texture2D(texture1, uv + refractVec2.xy * 0.5);
			vec4 color3 = texture2D(texture1, uv + refractVec3.xy * 0.5);

			// attenuate color intensity based on light angle
			// color1 *= dProd;
			// color2 *= dProd;
			// color3 *= dProd;

			//vec3 finalColor = vec3(color1.r, color2.g, color3.b);
			vec3 finalColor = texture2D(texture1, uv).rgb;

			gl_FragColor = vec4(finalColor, 1.0);
		}
	</script>

	<script id="quadVertShader" type="x-shader/x-vertex">
		uniform float iTime;
		varying vec2 vUv;
		varying vec3 vNormal;
	
		void main() {
			vUv = uv;
			vNormal = normal;

			//gl_Position = vec4(position, 1.0);
	
			
			gl_Position =   projectionMatrix * 
							modelViewMatrix * 
							vec4(position,1.0);
			
		}
	</script>

	<script id="quadFragShader" type="x-shader/x-fragment">
		#define sat(x) clamp(x, 0.0, 1.0);
		
		uniform float iTime;
		uniform sampler2D bgTexture;
		uniform sampler2D distortionTexture;
		uniform sampler2D edgesTexture;
	
		varying vec2 vUv;

		float remap01(float a, float b, float t) {
			return sat((t - a) / (b - a));  
		}
		
		
		float remap(float a, float b, float c, float d, float t) {
				return remap01(a, b, t) * (d - c) + c;
		}
	
		void main() {
			vec4 bgColor = texture2D(bgTexture, vUv);
			vec4 normalColor = texture2D(distortionTexture, vUv);
			vec4 edgesColor = texture2D(edgesTexture, vUv);
			vec3 normal = normalize(normalColor.rgb * 2.0 - 1.0);

			// remap edges color
			float edgeVal = remap(0.0, 1.0, 0.0, 0.7, edgesColor.r);
			
			vec3 refractVec1 = refract(vec3(0.0, 0.0, 1.0), normal, 0.5);
			vec3 refractVec2 = refract(vec3(0.05, 0.0, 1.0), normal, 0.5);
			vec3 refractVec3 = refract(vec3(-0.05, 0.0, 1.0), normal, 0.5);
			vec4 refractColor1 = texture2D(bgTexture, vUv + (refractVec1.xy * edgesColor.r));
			vec4 refractColor2 = texture2D(bgTexture, vUv + (refractVec2.xy * edgesColor.r));
			vec4 refractColor3 = texture2D(bgTexture, vUv + (refractVec3.xy * edgesColor.r));

			vec4 chromAberrColor = vec4(refractColor1.r, refractColor2.g, refractColor3.b, 1.0);

			vec3 refractVec = refract(vec3(0.0, 0.0, 1.0), normal, 0.0);
			vec4 refractColor = texture2D(bgTexture, vUv + (refractVec.xy * edgesColor.r));

			vec4 color = refractColor;
			
			// mix in chromatic aberration colors
			color = mix(refractColor, chromAberrColor, edgesColor.r);
			
			// mix in the edges color white
			color = mix(color, edgesColor, edgesColor.r / 8.0);



			// border
			color = mix(color, vec4(1.0, 0.0, 0.0, 1.0), smoothstep(0.01, 0.0, vUv.x) + smoothstep(0.99, 1.0, vUv.x) + smoothstep(0.01, 0.0, vUv.y) + smoothstep(0.99, 1.0, vUv.y));

			gl_FragColor = vec4(color);
		}
	</script>

	<script type="module">

		import * as THREE from '../build/three.module.js';

		import { BasisTextureLoader } from './jsm/loaders/BasisTextureLoader.js';
		import { GLTFLoader } from './jsm/loaders/GLTFLoader.js';
		import { OrbitControls } from './jsm/controls/OrbitControls.js';
		import { Float32BufferAttribute } from '../src/core/BufferAttribute.js';

		var camera, scene, renderer;
		var mesh;

		var clock = new THREE.Clock();
		var distPlaneNormals, distPlaneNormalsClone, bgVertShader, bgFragShader, quadVertShader, quadFragShader, distPlaneNormalsVertShader, distPlaneNormalsFragShader;
		var uniforms, colorTexture, maskTexture;
		var textureOffset = 0;
		var controls;
		var bgUniforms, bgTexture, bgMesh, bgRenderTarget, bgRtCamera, bgRtScene;
		var distortionNormalsScene, distortionNormalsCamera, distortionNormalsRenderTarget;
		var fsQuad, fsQuadUniforms;
		var distPlaneEdges, distPlaneEdgesClone, distPlaneEdgesVertShader, distPlaneEdgesFragShader;
		var distortionEdgesScene, distortionEdgesCamera, distortionEdgesRenderTarget;


		init();
		animate();

		function init() {

			renderer = new THREE.WebGLRenderer({ antialias: true });
			renderer.setPixelRatio(window.devicePixelRatio);
			renderer.setSize(window.innerWidth, window.innerHeight);
			renderer.gammaOutput = true;
			renderer.gammaFactor = 2.2;
			document.body.appendChild(renderer.domElement);
			bgVertShader = document.getElementById('bgVertShader').innerHTML;
			bgFragShader = document.getElementById('bgFragShader').innerHTML;
			quadVertShader = document.getElementById('quadVertShader').innerHTML;
			quadFragShader = document.getElementById('quadFragShader').innerHTML;
			distPlaneNormalsFragShader = document.getElementById('distPlaneNormalsFragShader').innerHTML;
			distPlaneNormalsVertShader = document.getElementById('distPlaneNormalsVertShader').innerHTML;
			distPlaneEdgesFragShader = document.getElementById('distPlaneEdgesFragShader').innerHTML;
			distPlaneEdgesVertShader = document.getElementById('distPlaneEdgesVertShader').innerHTML;

			bgRenderTarget = new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight);
			bgRtCamera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 2000);
			bgRtCamera.position.set(0, 0, 5);

			distortionNormalsRenderTarget = new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight);
			distortionNormalsCamera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 2000);
			distortionNormalsCamera.position.set(0, 0, 5);

			distortionEdgesRenderTarget = new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight);
			distortionEdgesCamera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 2000);
			distortionEdgesCamera.position.set(0, 0, 5);


			camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 2000);
			camera.position.set(0, 0, 5);



			scene = new THREE.Scene();
			bgRtScene = new THREE.Scene();
			distortionNormalsScene = new THREE.Scene();
			distortionEdgesScene = new THREE.Scene();


			makeBackgroundPlane();

			makeDistortionPlanes();

			makeFsQuad();


			window.addEventListener('resize', onWindowResize, false);

		}

		function makeFsQuad() {

			let geo = new THREE.PlaneGeometry(2, 2);

			fsQuadUniforms = {
				iTime: {
					value: 0
				},
				bgTexture: {
					type: "t",
					value: bgRenderTarget.texture
				},
				distortionTexture: {
					type: "t",
					value: distortionNormalsRenderTarget.texture
				},
				edgesTexture: {
					type: 't',
					value: distortionEdgesRenderTarget.texture
				}
			};

			let material = new THREE.ShaderMaterial({
				vertexShader: quadVertShader,
				fragmentShader: quadFragShader,
				uniforms: fsQuadUniforms,
				// depthWrite: false,
				// depthTest: false
			});

			fsQuad = new THREE.Mesh(geo, material);
			fsQuad.position.set(-1, 1, 0);

			scene.add(fsQuad);
		}

		function makeBackgroundPlane() {
			bgTexture = THREE.ImageUtils.loadTexture("textures/allyouseeis.png");

			var geometry = new THREE.PlaneBufferGeometry(20, 20, 8, 8);

			bgUniforms = {
				iTime: {
					value: 0
				},
				texture1: {
					type: "t",
					value: bgTexture
				},
			};

			var material = new THREE.ShaderMaterial({
				uniforms: bgUniforms,
				vertexShader: bgVertShader,
				fragmentShader: bgFragShader,
				side: THREE.DoubleSide,
				transparent: true
			});

			bgMesh = new THREE.Mesh(geometry, material);
			bgMesh.name = 'bgMesh';
			bgMesh.position.set(0, 0, -40);
			bgMesh.scale.set(1, 1, 1);
			let foo = bgMesh.clone();
			scene.add(foo);
			bgRtScene.add(bgMesh);
			console.log(bgRtScene);

		}

		function makeDistortionPlanes() {
			let distRange = 16;

			var geometry = new THREE.PlaneBufferGeometry(20, 20, 4, 4);
			// var geometry = new THREE.PlaneBufferGeometry(20, 20, 1, 1);

			// var material = new THREE.MeshNormalMaterial();
			var normalsMaterial = new THREE.ShaderMaterial({
				uniforms: {},
				vertexShader: distPlaneNormalsVertShader,
				fragmentShader: distPlaneNormalsFragShader
			});

			var edgesMaterial = new THREE.ShaderMaterial({
				uniforms: {},
				vertexShader: distPlaneEdgesVertShader,
				fragmentShader: distPlaneEdgesFragShader
			});

			// offset vertices
			let positions = geometry.attributes.position.array;
			for (let i = 0; i < positions.length; i += 2) {
				positions[i] += Math.random() * distRange - (distRange / 2);
			}

			// clone geometry
			var edgesGeo = geometry.clone();

			// create barycentric data
			let barycentricData = [];
			let indexCount = 0;
			for (let i = 0; i < positions.length; i += 3) {
				if (indexCount % 3 === 0) {
					barycentricData.push(1, 0, 0);
				} else if (indexCount % 3 === 1) {
					barycentricData.push(0, 1, 0);
				} else if (indexCount % 3 === 2) {
					barycentricData.push(0, 0, 1);
				}
				indexCount++;
			}

			// add barycentric data to edges geometry
			edgesGeo.addAttribute('barycentric', new Float32BufferAttribute(barycentricData, 3));



			geometry.computeVertexNormals();
			geometry.computeFaceNormals();
			edgesGeo.computeVertexNormals();
			edgesGeo.computeFaceNormals();

			geometry.verticesNeedUpdate = true;
			geometry.normalsNeedUpdate = true;
			geometry.uvsNeedUpdate = true;
			normalsMaterial.needsUpdate = true;
			edgesGeo.verticesNeedUpdate = true;
			edgesGeo.normalsNeedUpdate = true;
			edgesGeo.uvsNeedUpdate = true;
			edgesMaterial.needsUpdate = true;

			distPlaneNormals = new THREE.Mesh(geometry, normalsMaterial);
			distPlaneNormals.position.set(0, 0, -30);
			distPlaneNormalsClone = distPlaneNormals.clone();

			distPlaneEdges = new THREE.Mesh(edgesGeo, edgesMaterial);
			distPlaneEdges.position.set(0, 0, -30);
			distPlaneEdgesClone = distPlaneEdges.clone();


			// scene.add(distPlaneNormalsClone);
			scene.add(distPlaneEdgesClone);
			distortionNormalsScene.add(distPlaneNormals);
			distortionEdgesScene.add(distPlaneEdges);


			console.log(edgesGeo);
		}

		function onWindowResize() {

			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();

			renderer.setSize(window.innerWidth, window.innerHeight);

		}





		function animate(time) {

			time *= 0.001;

			requestAnimationFrame(animate);

			var delta = clock.getDelta() * 0.5;

			if (distPlaneNormals) {
				distPlaneNormals.rotation.y = 0.3 * Math.sin(time);
				distPlaneEdges.rotation.y = 0.3 * Math.sin(time);
			}

			renderer.setRenderTarget(bgRenderTarget);
			renderer.render(bgRtScene, bgRtCamera);
			renderer.setRenderTarget(distortionNormalsRenderTarget);
			renderer.render(distortionNormalsScene, distortionNormalsCamera);
			renderer.setRenderTarget(distortionEdgesRenderTarget);
			renderer.render(distortionEdgesScene, distortionEdgesCamera);
			renderer.setRenderTarget(null);

			renderer.render(scene, camera);

		}



	</script>

</body>

</html>
