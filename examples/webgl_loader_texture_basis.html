<!DOCTYPE html>
<html lang="en">

<head>
	<title>three.js webgl - basis texture loader</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<link type="text/css" rel="stylesheet" href="main.css">
</head>

<body>

	<script id="distPlaneVertShader" type="x-shader/x-vertex">
		varying vec2 vUv;
		varying vec3 vNormal;
		varying vec3 vBC;

		attribute vec3 barycentric;
	
		void main() {
			vUv = uv;
			vNormal = normalMatrix * normalize(normal);
			vBC = barycentric;
	
			gl_Position =   projectionMatrix * 
							modelViewMatrix * 
							vec4(position,1.0);
		}
	</script>

	<script id="distPlaneFragShader" type="x-shader/x-fragment">
		varying vec2 vUv;
		varying mediump vec3 vNormal;
		varying vec3 vBC;
	
		void main() {
			vec3 view_nv = normalize(vNormal);
			float dist = distance(vec3(0.0), vBC);
			vec3 nv_color = view_nv * 0.5 + 0.5;
			
			nv_color = mix(nv_color, vec3(1.0), dist);
			gl_FragColor = vec4(nv_color, 1.0);
		}
	</script>


	<script id="bgVertShader" type="x-shader/x-vertex">
		uniform float iTime;
		varying vec2 vUv;
		varying vec3 vNormal;
	
		void main() {
			vUv = uv;
			vNormal = normal;
	
			gl_Position =   projectionMatrix * 
							modelViewMatrix * 
							vec4(position,1.0);
		}
	</script>

	<script id="bgFragShader" type="x-shader/x-fragment">
		uniform float iTime;
		uniform sampler2D texture1;
	
		varying vec2 vUv;
		varying mediump vec3 vNormal;
	
		void main() {
			mediump vec3 light = vec3(0.0, 0.0, 1.0);
			vec2 uv = vUv;

			// ensure it's normalized
			light = normalize(light);

			
			// calculate the dot product of
			// the light to the vertex normal
			mediump float dProd = max(0.0, dot(vNormal, light));

			vec3 refractVec1 = refract(light, vNormal, 0.2);
			vec3 refractVec2 = refract(vec3(0.2, 0.0, 1.0), vNormal, 0.2);
			vec3 refractVec3 = refract(vec3(0.4, 0.0, 1.0), vNormal, 0.2);

			vec4 color1 = texture2D(texture1, uv + refractVec1.xy * 0.5);
			vec4 color2 = texture2D(texture1, uv + refractVec2.xy * 0.5);
			vec4 color3 = texture2D(texture1, uv + refractVec3.xy * 0.5);

			// attenuate color intensity based on light angle
			// color1 *= dProd;
			// color2 *= dProd;
			// color3 *= dProd;

			//vec3 finalColor = vec3(color1.r, color2.g, color3.b);
			vec3 finalColor = texture2D(texture1, uv).rgb;

			gl_FragColor = vec4(finalColor, 1.0);
		}
	</script>

	<script id="quadVertShader" type="x-shader/x-vertex">
		uniform float iTime;
		varying vec2 vUv;
		varying vec3 vNormal;
	
		void main() {
			vUv = uv;
			vNormal = normal;

			//gl_Position = vec4(position, 1.0);
	
			
			gl_Position =   projectionMatrix * 
							modelViewMatrix * 
							vec4(position,1.0);
			
		}
	</script>

	<script id="quadFragShader" type="x-shader/x-fragment">
		uniform float iTime;
		uniform sampler2D bgTexture;
		uniform sampler2D distortionTexture;
	
		varying vec2 vUv;

		
	
		void main() {
			vec4 bgColor = texture2D(bgTexture, vUv);
			vec4 normalColor = texture2D(distortionTexture, vUv);
			vec3 normal = normalize(normalColor.rgb * 2.0 - 1.0);
			
			vec3 refractVec1 = refract(vec3(0.0, 0.0, 1.0), normal, 0.2);
			vec3 refractVec2 = refract(vec3(0.2, 0.0, 1.0), normal, 0.2);
			vec3 refractVec3 = refract(vec3(0.2, 0.0, 1.0), normal, 0.2);
			vec4 refractColor1 = texture2D(bgTexture, vUv + refractVec1.xy * 0.3);
			vec4 refractColor2 = texture2D(bgTexture, vUv + refractVec2.xy * 0.3);
			vec4 refractColor3 = texture2D(bgTexture, vUv + refractVec3.xy * 0.3);

			vec4 refractColor = vec4(refractColor1.r, refractColor2.g, refractColor3.b, 1.0);

			// normalColor.a determines if we need to use the refracted colors or not
			vec4 color = bgColor + refractColor * normalColor.a;

			// border
			color = mix(color, vec4(1.0, 0.0, 0.0, 1.0), smoothstep(0.01, 0.0, vUv.x) + smoothstep(0.99, 1.0, vUv.x) + smoothstep(0.01, 0.0, vUv.y) + smoothstep(0.99, 1.0, vUv.y));

			gl_FragColor = vec4(color);
		}
	</script>

	<script type="module">

		import * as THREE from '../build/three.module.js';

		import { BasisTextureLoader } from './jsm/loaders/BasisTextureLoader.js';
		import { GLTFLoader } from './jsm/loaders/GLTFLoader.js';
		import { OrbitControls } from './jsm/controls/OrbitControls.js';
		import { Float32BufferAttribute } from '../src/core/BufferAttribute.js';

		var camera, scene, renderer;
		var mesh;

		var clock = new THREE.Clock();
		var thing, thingClone, bgVertShader, bgFragShader, quadVertShader, quadFragShader, distPlaneVertShader, distPlaneFragShader;
		var uniforms, colorTexture, maskTexture;
		var textureOffset = 0;
		var controls;
		var bgUniforms, bgTexture, bgMesh, bgRenderTarget, bgRtCamera, bgRtScene;
		var distortionScene, distortionCamera, distortionRenderTarget;
		var fsQuad, fsQuadUniforms;


		init();
		animate();

		function init() {

			renderer = new THREE.WebGLRenderer({ antialias: true });
			renderer.setPixelRatio(window.devicePixelRatio);
			renderer.setSize(window.innerWidth, window.innerHeight);
			renderer.gammaOutput = true;
			renderer.gammaFactor = 2.2;
			document.body.appendChild(renderer.domElement);
			bgVertShader = document.getElementById('bgVertShader').innerHTML;
			bgFragShader = document.getElementById('bgFragShader').innerHTML;
			quadVertShader = document.getElementById('quadVertShader').innerHTML;
			quadFragShader = document.getElementById('quadFragShader').innerHTML;
			distPlaneFragShader = document.getElementById('distPlaneFragShader').innerHTML;
			distPlaneVertShader = document.getElementById('distPlaneVertShader').innerHTML;

			bgRenderTarget = new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight);
			bgRtCamera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 2000);
			bgRtCamera.position.set(0, 0, 5);

			distortionRenderTarget = new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight);
			distortionCamera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 2000);
			distortionCamera.position.set(0, 0, 5);


			camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 2000);
			camera.position.set(0, 0, 5);



			scene = new THREE.Scene();
			bgRtScene = new THREE.Scene();
			distortionScene = new THREE.Scene();


			//loadGltfModel();
			makeBackgroundPlane();

			makeDistortionPlane();


			makeFsQuad();


			window.addEventListener('resize', onWindowResize, false);

		}

		function makeFsQuad() {

			let geo = new THREE.PlaneGeometry(2, 2);

			fsQuadUniforms = {
				iTime: {
					value: 0
				},
				bgTexture: {
					type: "t",
					value: bgRenderTarget.texture
				},
				distortionTexture: {
					type: "t",
					value: distortionRenderTarget.texture
				}
			};

			let material = new THREE.ShaderMaterial({
				vertexShader: quadVertShader,
				fragmentShader: quadFragShader,
				uniforms: fsQuadUniforms,
				// depthWrite: false,
				// depthTest: false
			});

			fsQuad = new THREE.Mesh(geo, material);
			fsQuad.position.set(-1, 1, 0);

			scene.add(fsQuad);
		}

		function makeBackgroundPlane() {
			bgTexture = THREE.ImageUtils.loadTexture("textures/allyouseeis.png");

			var geometry = new THREE.PlaneBufferGeometry(20, 20, 8, 8);

			bgUniforms = {
				iTime: {
					value: 0
				},
				texture1: {
					type: "t",
					value: bgTexture
				},
			};

			var material = new THREE.ShaderMaterial({
				uniforms: bgUniforms,
				vertexShader: bgVertShader,
				fragmentShader: bgFragShader,
				side: THREE.DoubleSide,
				transparent: true
			});

			bgMesh = new THREE.Mesh(geometry, material);
			bgMesh.name = 'bgMesh';
			bgMesh.position.set(0, 0, -40);
			bgMesh.scale.set(1, 1, 1);
			// scene.add(bgMesh);
			bgRtScene.add(bgMesh);
			console.log(bgRtScene);

		}

		function makeDistortionPlane() {
			let distRange = 2;

			var geometry = new THREE.PlaneBufferGeometry(20, 20, 8, 8);

			// var material = new THREE.MeshNormalMaterial();
			var material = new THREE.ShaderMaterial({
				uniforms: {},
				vertexShader: distPlaneVertShader,
				fragmentShader: distPlaneFragShader
			});

			// offset vertices
			let positions = geometry.attributes.position.array;
			for (let i = 0; i < positions.length; i += 5) {
				positions[i] += Math.random() * distRange - (distRange / 2);
			}

			// create barycentric data
			let barycentricData = [];
			let indexCount = 0;
			for (let i = 0; i < positions.length; i += 3) {


				if (indexCount % 3 === 0) {
					barycentricData.push(1, 0, 0);
				} else if (indexCount % 3 === 1) {
					barycentricData.push(0, 1, 0);
				} else if (indexCount % 3 === 2) {
					barycentricData.push(0, 0, 1);
				}

				indexCount++;
			}

			// add barycentric data to geometry
			geometry.addAttribute('barycentric', new Float32BufferAttribute(barycentricData, 3));



			geometry.computeVertexNormals();
			geometry.computeFaceNormals();

			geometry.verticesNeedUpdate = true;
			geometry.normalsNeedUpdate = true;
			geometry.uvsNeedUpdate = true;
			material.needsUpdate = true;

			thing = new THREE.Mesh(geometry, material);
			thing.position.set(0, 0, -30);
			let thingClone = thing.clone();
			scene.add(thingClone);
			distortionScene.add(thing);


			console.log(geometry);
		}

		function onWindowResize() {

			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();

			renderer.setSize(window.innerWidth, window.innerHeight);

		}





		function animate(time) {

			time *= 0.001;

			requestAnimationFrame(animate);

			var delta = clock.getDelta() * 0.5;

			if (thing) {
				thing.rotation.y = 0.3 * Math.sin(time);
			}

			renderer.setRenderTarget(bgRenderTarget);
			renderer.render(bgRtScene, bgRtCamera);
			renderer.setRenderTarget(distortionRenderTarget);
			renderer.render(distortionScene, distortionCamera);
			renderer.setRenderTarget(null);

			renderer.render(scene, camera);

		}



	</script>

</body>

</html>
