<!DOCTYPE html>
<html lang="en">

<head>
	<title>three.js webgl - basis texture loader</title>
	<meta charset="utf-8" />
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0" />
	<link type="text/css" rel="stylesheet" href="main.css" />
	<link href="https://fonts.googleapis.com/css?family=Oswald&display=swap" rel="stylesheet">
</head>

<body>
	<script src="https://cdn.jsdelivr.net/npm/tweakpane@1.0.5/dist/tweakpane.min.js"></script>
	<script id="distPlaneEdgesVertShader" type="x-shader/x-vertex">
			varying vec2 vUv;
			varying vec3 vBC;

			attribute vec3 barycentric;

			void main() {
				vUv = uv;
				vBC = barycentric;

				gl_Position =   projectionMatrix *
								modelViewMatrix *
								vec4(position,1.0);
			}
		</script>

	<script id="distPlaneEdgesFragShader" type="x-shader/x-fragment">
			varying vec2 vUv;
			varying vec3 vBC;

			uniform float u_edgesThickness;

			void main() {
				float color = pow(distance(vec3(0.33), vBC), u_edgesThickness);
				vec3 white = vec3(1.0, 1.0, 1.0);
				// x * y * z = 0 if any of the components is 0
				float line = 1.0 - smoothstep(0.0, 0.005, vBC.x * vBC.y * vBC.z);
				vec3 finalColor = mix(vec3(color), white, line);
				gl_FragColor = vec4(finalColor, 1.0);
			}
		</script>

	<script id="distPlaneNormalsVertShader" type="x-shader/x-vertex">
			varying vec2 vUv;
			varying vec3 vNormal;
			varying vec3 vBC;


			void main() {
				vUv = uv;
				vNormal = normalMatrix * normalize(normal);

				gl_Position =   projectionMatrix *
								modelViewMatrix *
								vec4(position,1.0);
			}
		</script>

	<script id="distPlaneNormalsFragShader" type="x-shader/x-fragment">
			varying vec2 vUv;
			varying mediump vec3 vNormal;

			void main() {
				vec3 view_nv = normalize(vNormal);
				vec3 nv_color = view_nv * 0.5 + 0.5;

				gl_FragColor = vec4(nv_color, 1.0);
			}
		</script>

	<script id="bgVertShader" type="x-shader/x-vertex">
			uniform float iTime;
			varying vec2 vUv;
			varying vec3 vNormal;

			void main() {
				vUv = uv;
				vNormal = normal;

				gl_Position =   projectionMatrix *
								modelViewMatrix *
								vec4(position,1.0);
			}
		</script>

	<script id="bgFragShader" type="x-shader/x-fragment">
			uniform float iTime;
			uniform sampler2D texture1;

			varying vec2 vUv;
			varying mediump vec3 vNormal;

			void main() {
				mediump vec3 light = vec3(0.0, 0.0, 1.0);
				vec2 uv = vUv;

				// ensure it's normalized
				light = normalize(light);


				// calculate the dot product of
				// the light to the vertex normal
				mediump float dProd = max(0.0, dot(vNormal, light));

				vec3 refractVec1 = refract(light, vNormal, 0.2);
				vec3 refractVec2 = refract(vec3(0.2, 0.0, 1.0), vNormal, 0.2);
				vec3 refractVec3 = refract(vec3(0.4, 0.0, 1.0), vNormal, 0.2);

				vec4 color1 = texture2D(texture1, uv + refractVec1.xy * 0.5);
				vec4 color2 = texture2D(texture1, uv + refractVec2.xy * 0.5);
				vec4 color3 = texture2D(texture1, uv + refractVec3.xy * 0.5);

				// attenuate color intensity based on light angle
				// color1 *= dProd;
				// color2 *= dProd;
				// color3 *= dProd;

				//vec3 finalColor = vec3(color1.r, color2.g, color3.b);
				vec3 finalColor = texture2D(texture1, uv).rgb;

				gl_FragColor = vec4(finalColor, 1.0);
			}
		</script>

	<script id="quadVertShader" type="x-shader/x-vertex">
			uniform float iTime;
			varying vec2 vUv;
			varying vec3 vNormal;

			void main() {
				vUv = uv;
				vNormal = normal;

				//gl_Position = vec4(position, 1.0);


				gl_Position =   projectionMatrix *
								modelViewMatrix *
								vec4(position,1.0);

			}
		</script>

	<script id="quadFragShader" type="x-shader/x-fragment">
			#define sat(x) clamp(x, 0.0, 1.0);

			uniform float iTime;
			uniform sampler2D bgTexture;
			uniform sampler2D distortionTexture;
			uniform sampler2D edgesTexture;
			uniform float edgesRenderStrength;
			uniform float chromaticAberrMod;

			varying vec2 vUv;

			float remap01(float a, float b, float t) {
				return sat((t - a) / (b - a));
			}


			float remap(float a, float b, float c, float d, float t) {
					return remap01(a, b, t) * (d - c) + c;
			}

			void main() {
				vec4 bgColor = texture2D(bgTexture, vUv);
				vec4 normalColor = texture2D(distortionTexture, vUv);
				vec4 edgesColor = texture2D(edgesTexture, vUv);
				vec3 normal = normalize(normalColor.rgb * 2.0 - 1.0);

				// remap edges color
				float edgeVal = remap(0.0, 1.0, 0.0, 0.7, edgesColor.r);

				vec3 refractVec1 = refract(vec3(0.0, 0.0, 1.0), normal, chromaticAberrMod);
				vec3 refractVec2 = refract(vec3(0.05, 0.0, 1.0), normal, chromaticAberrMod);
				vec3 refractVec3 = refract(vec3(-0.05, 0.0, 1.0), normal, chromaticAberrMod);
				vec4 refractColor1 = texture2D(bgTexture, vUv + (refractVec1.xy * edgesColor.r));
				vec4 refractColor2 = texture2D(bgTexture, vUv + (refractVec2.xy * edgesColor.r));
				vec4 refractColor3 = texture2D(bgTexture, vUv + (refractVec3.xy * edgesColor.r));

				vec4 chromAberrColor = vec4(refractColor1.r, refractColor2.g, refractColor3.b, 1.0);

				vec3 refractVec = refract(vec3(0.0, 0.0, 1.0), normal, 0.0);
				vec4 refractColor = texture2D(bgTexture, vUv + (refractVec.xy * edgesColor.r));

				vec4 color = refractColor;

				// mix in chromatic aberration colors
				color = mix(refractColor, chromAberrColor, edgesColor.r);

				// mix in the edges color white
				color = mix(color, edgesColor, edgesColor.r / edgesRenderStrength);



				// border
				color = mix(color, vec4(1.0, 0.0, 0.0, 1.0), smoothstep(0.01, 0.0, vUv.x) + smoothstep(0.99, 1.0, vUv.x) + smoothstep(0.01, 0.0, vUv.y) + smoothstep(0.99, 1.0, vUv.y));

				gl_FragColor = vec4(color);
			}
		</script>

	<!-- 
			*******************************
			******************************
		 -->
	<script type="module">
		import * as THREE from '../build/three.module.js';

		import { BasisTextureLoader } from './jsm/loaders/BasisTextureLoader.js';
		import { GLTFLoader } from './jsm/loaders/GLTFLoader.js';
		import { OrbitControls } from './jsm/controls/OrbitControls.js';
		import { Float32BufferAttribute } from '../src/core/BufferAttribute.js';
		import '../node_modules/fontfaceobserver/fontfaceobserver.js';

		var PARAMS = {
			speed: 0.5,
			edgesThickness: 3.0,
			distRange: 0,//16,
			planeSubdiv: 4,
			edgesRenderStrength: 8.0,
			chromaticAberrMod: 0.1,
			rotateSpeed: 0.2
		};
		var pane;

		var camera, scene, renderer;
		var mesh;

		var clock = new THREE.Clock();
		var distPlaneNormals,
			distPlaneNormalsClone,
			bgVertShader,
			bgFragShader,
			quadVertShader,
			quadFragShader,
			distPlaneNormalsVertShader,
			distPlaneNormalsFragShader;
		var uniforms, colorTexture, maskTexture;
		var textureOffset = 0;
		var controls;
		var bgUniforms, bgTexture, bgMesh, bgRenderTarget, bgRtCamera, bgRtScene;
		var distortionNormalsScene,
			distortionNormalsCamera,
			distortionNormalsRenderTarget;
		var fsQuad, fsQuadUniforms;
		var distPlaneEdges,
			distPlaneEdgesClone,
			distPlaneEdgesVertShader,
			distPlaneEdgesFragShader;
		var distortionEdgesScene,
			distortionEdgesCamera,
			distortionEdgesRenderTarget;

		var edgesUniforms, distRange;
		var bgCanvas;
		var bgCanvasCtx;
		var bgCanvasTexture;
		var canvasWidth, canvasHeight;
		var textLines;

		var fontLoader = new FontFaceObserver('Oswald');
		fontLoader.load().then(() => {
			console.log('font is LOADED');
			init();
			animate();
			addPaneParams();
		}, () => {
			console.log('font is NOT AVAILABLE');
		})


		/*************************
		INIT
		*************************/

		function init() {
			pane = new Tweakpane();

			renderer = new THREE.WebGLRenderer({ antialias: true });
			renderer.setPixelRatio(window.devicePixelRatio);
			renderer.setSize(window.innerWidth, window.innerHeight);
			renderer.gammaOutput = true;
			renderer.gammaFactor = 2.2;
			document.body.appendChild(renderer.domElement);
			bgVertShader = document.getElementById('bgVertShader').innerHTML;
			bgFragShader = document.getElementById('bgFragShader').innerHTML;
			quadVertShader = document.getElementById('quadVertShader').innerHTML;
			quadFragShader = document.getElementById('quadFragShader').innerHTML;
			distPlaneNormalsFragShader = document.getElementById(
				'distPlaneNormalsFragShader'
			).innerHTML;
			distPlaneNormalsVertShader = document.getElementById(
				'distPlaneNormalsVertShader'
			).innerHTML;
			distPlaneEdgesFragShader = document.getElementById(
				'distPlaneEdgesFragShader'
			).innerHTML;
			distPlaneEdgesVertShader = document.getElementById(
				'distPlaneEdgesVertShader'
			).innerHTML;

			bgRenderTarget = new THREE.WebGLRenderTarget(
				window.innerWidth,
				window.innerHeight
			);
			bgRtCamera = new THREE.PerspectiveCamera(
				50,
				window.innerWidth / window.innerHeight,
				1,
				2000
			);
			bgRtCamera.position.set(0, 0, 5);

			distortionNormalsRenderTarget = new THREE.WebGLRenderTarget(
				window.innerWidth,
				window.innerHeight
			);
			distortionNormalsCamera = new THREE.PerspectiveCamera(
				50,
				window.innerWidth / window.innerHeight,
				1,
				2000
			);
			distortionNormalsCamera.position.set(0, 0, 5);

			distortionEdgesRenderTarget = new THREE.WebGLRenderTarget(
				window.innerWidth,
				window.innerHeight
			);
			distortionEdgesCamera = new THREE.PerspectiveCamera(
				50,
				window.innerWidth / window.innerHeight,
				1,
				2000
			);
			distortionEdgesCamera.position.set(0, 0, 5);

			camera = new THREE.PerspectiveCamera(
				50,
				window.innerWidth / window.innerHeight,
				1,
				2000
			);
			camera.position.set(0, 0, 5);

			scene = new THREE.Scene();
			bgRtScene = new THREE.Scene();
			distortionNormalsScene = new THREE.Scene();
			distortionEdgesScene = new THREE.Scene();

			makeBgCanvas();
			makeBackgroundPlane();
			makeDistortionPlanes();
			makeFsQuad();

			window.addEventListener('resize', onWindowResize, false);
		}

		/*************************
		MAKE BG CANVAS
		*************************/

		function makeBgCanvas() {
			class TextLine {
				constructor(startX, startY, snippetWidth, snippetPadding, scrollSpeed, scrollDir) {
					this.snippets = [
						{
							x: startX,
							y: startY
						},
						{
							x: startX + (snippetWidth + snippetPadding) * 1,
							y: startY,
						},
						{
							x: startX + (snippetWidth + snippetPadding) * 2,
							y: startY,
						}
					];

					this.scrollSpeed = scrollSpeed;
					this.scrollDir = scrollDir;
					this.snippetWidth = snippetWidth;
					this.snippetPadding = snippetPadding;
				}

				returnFirstSnippet() {
					let firstSnippet = null;

					firstSnippet = this.snippets.reduce((accum, currVal) => {
						return accum.x < currVal.x ? accum : currVal;
					});

					return firstSnippet;
				}

				returnLastSnippet() {
					let lastSnippet = null;

					// case: we going left
					lastSnippet = this.snippets.reduce((accum, currVal) => {
						return accum.x > currVal.x ? accum : currVal;
					});

					return lastSnippet;
				}

				checkLastSnippet() {
					const firstSnippet = this.returnFirstSnippet();
					const lastSnippet = this.returnLastSnippet();
					const totalSnippetWidth = this.snippetWidth + this.snippetPadding;

					console.log('first:  ', firstSnippet);
					console.log(lastSnippet);

					// if lastSnippet is offscreen
					if (this.scrollDir < 0) {
						// case: going left
						if (firstSnippet.x + totalSnippetWidth < 0) {
							//case:  the farthest left snippet is off screen, move it to the end
							firstSnippet.x = lastSnippet.x + totalSnippetWidth;
						}
					} else {
						// case: going right
						if (lastSnippet.x - totalSnippetWidth > canvasWidth) {
							// case:  the farthest right snippet is off screen, move it to the beginning
							lastSnippet.x = firstSnippet.x - totalSnippetWidth;
						}
					}

				}

				update(time) {
					for (let i = 0; i < this.snippets.length; i++) {
						this.snippets[i].x += (this.scrollSpeed * this.scrollDir);
					}

					this.checkLastSnippet();
				}

				draw() {
					for (let i = 0; i < this.snippets.length; i++) {
						bgCanvasCtx.font = fontSize + 'px Oswald';
						bgCanvasCtx.fillStyle = 'black';
						bgCanvasCtx.textAlign = "center";
						bgCanvasCtx.textBaseline = "middle";
						bgCanvasCtx.fillText('ALL YOU SEE IS', this.snippets[i].x, this.snippets[i].y);
					}
				}
			}

			bgCanvas = document.createElement('canvas');
			bgCanvasCtx = bgCanvas.getContext('2d');
			bgCanvas.width = bgCanvas.height = canvasWidth = canvasHeight = 1024;
			bgCanvasTexture = new THREE.CanvasTexture(bgCanvas);
			bgCanvasTexture.needsUpdate = true;

			let fontSize = 180;
			bgCanvasCtx.font = fontSize + 'px Oswald';
			bgCanvasCtx.fillStyle = 'black';
			bgCanvasCtx.textAlign = "center";
			bgCanvasCtx.textBaseline = "middle";
			let textMetric = bgCanvasCtx.measureText('ALL YOU SEE IS');
			let textSnippetWidth = textMetric.width;
			let textSnippetsPerLine = Math.ceil((canvasWidth / textSnippetWidth) + 2);
			let textLineCount = Math.ceil(canvasHeight / fontSize) + 1;
			let textLineHeight = fontSize;
			let snippetPadding = 45;
			let scrollSpeed = 1;
			textLines = [];

			// instantiate text lines
			for (let i = 0; i < textLineCount; i++) {
				let offset = Math.random() * (textSnippetWidth / 2);
				let textLine = new TextLine(0 + offset, i * textLineHeight, textSnippetWidth, snippetPadding, scrollSpeed, i % 2 === 0 ? -1 : 1);
				textLines.push(textLine);
			}

		}

		/*************************
		FULL SCREEN QUAD
		*************************/

		function makeFsQuad() {
			let geo = new THREE.PlaneGeometry(2, 2);

			fsQuadUniforms = {
				iTime: {
					value: 0
				},
				bgTexture: {
					type: 't',
					value: bgCanvasTexture//bgRenderTarget.texture
				},
				distortionTexture: {
					type: 't',
					value: distortionNormalsRenderTarget.texture
				},
				edgesTexture: {
					type: 't',
					value: distortionEdgesRenderTarget.texture
				},
				edgesRenderStrength: {
					value: PARAMS.edgesRenderStrength
				},
				chromaticAberrMod: {
					value: PARAMS.chromaticAberrMod
				}
			};

			let material = new THREE.ShaderMaterial({
				vertexShader: quadVertShader,
				fragmentShader: quadFragShader,
				uniforms: fsQuadUniforms
				// depthWrite: false,
				// depthTest: false
			});

			fsQuad = new THREE.Mesh(geo, material);
			fsQuad.position.set(0, 0, 0);
			fsQuad.scale.set(2, 2, 2);

			scene.add(fsQuad);
		}

		/*************************
		BACKGROUND PLANE
		*************************/

		function makeBackgroundPlane() {
			bgTexture = THREE.ImageUtils.loadTexture('textures/allyouseeis.png');

			var geometry = new THREE.PlaneBufferGeometry(20, 20, 8, 8);

			bgUniforms = {
				iTime: {
					value: 0
				},
				texture1: {
					type: 't',
					value: bgTexture
				}
			};

			var material = new THREE.ShaderMaterial({
				uniforms: bgUniforms,
				vertexShader: bgVertShader,
				fragmentShader: bgFragShader,
				side: THREE.DoubleSide,
				transparent: true
			});

			bgMesh = new THREE.Mesh(geometry, material);
			bgMesh.name = 'bgMesh';
			bgMesh.position.set(0, 0, -40);
			bgMesh.scale.set(1, 1, 1);
			let foo = bgMesh.clone();
			scene.add(foo);
			bgRtScene.add(bgMesh);
			console.log(bgRtScene);
		}

		/*************************
		DISTORTION PLANES
		*************************/
		function makeDistortionPlanes(reset) {
			if (reset) {
				scene.remove(distPlaneNormalsClone);
				scene.remove(distPlaneEdgesClone);
				distortionNormalsScene.remove(distPlaneNormals);
				distortionEdgesScene.remove(distPlaneEdges);
			}

			distRange = PARAMS.distRange;
			edgesUniforms = {
				u_edgesThickness: {
					type: 'f',
					value: PARAMS.edgesThickness
				}
			};

			var geometry = new THREE.PlaneBufferGeometry(
				20,
				20,
				PARAMS.planeSubdiv,
				PARAMS.planeSubdiv
			);
			// var geometry = new THREE.PlaneBufferGeometry(20, 20, 1, 1);

			// var material = new THREE.MeshNormalMaterial();
			var normalsMaterial = new THREE.ShaderMaterial({
				uniforms: {},
				vertexShader: distPlaneNormalsVertShader,
				fragmentShader: distPlaneNormalsFragShader
			});

			var edgesMaterial = new THREE.ShaderMaterial({
				uniforms: edgesUniforms,
				vertexShader: distPlaneEdgesVertShader,
				fragmentShader: distPlaneEdgesFragShader
			});

			// offset vertices
			let positions = geometry.attributes.position.array;
			for (let i = 0; i < positions.length; i += 2) {
				positions[i] += Math.random() * distRange - distRange / 2;
			}

			// clone geometry
			var edgesGeo = geometry.clone();

			// create barycentric data
			let barycentricData = [];
			let indexCount = 0;
			for (let i = 0; i < positions.length; i += 3) {
				if (indexCount % 3 === 0) {
					barycentricData.push(1, 0, 0);
				} else if (indexCount % 3 === 1) {
					barycentricData.push(0, 1, 0);
				} else if (indexCount % 3 === 2) {
					barycentricData.push(0, 0, 1);
				}
				indexCount++;
			}

			// add barycentric data to edges geometry
			edgesGeo.addAttribute(
				'barycentric',
				new Float32BufferAttribute(barycentricData, 3)
			);

			geometry.computeVertexNormals();
			geometry.computeFaceNormals();
			edgesGeo.computeVertexNormals();
			edgesGeo.computeFaceNormals();

			geometry.verticesNeedUpdate = true;
			geometry.normalsNeedUpdate = true;
			geometry.uvsNeedUpdate = true;
			normalsMaterial.needsUpdate = true;
			edgesGeo.verticesNeedUpdate = true;
			edgesGeo.normalsNeedUpdate = true;
			edgesGeo.uvsNeedUpdate = true;
			edgesMaterial.needsUpdate = true;

			distPlaneNormals = new THREE.Mesh(geometry, normalsMaterial);
			distPlaneNormals.position.set(0, 0, -30);
			distPlaneNormalsClone = distPlaneNormals.clone();

			distPlaneEdges = new THREE.Mesh(edgesGeo, edgesMaterial);
			distPlaneEdges.position.set(0, 0, -30);
			distPlaneEdgesClone = distPlaneEdges.clone();

			// scene.add(distPlaneNormalsClone);
			scene.add(distPlaneEdgesClone);
			distortionNormalsScene.add(distPlaneNormals);
			distortionEdgesScene.add(distPlaneEdges);

			console.log(edgesGeo);
		}

		/*************************
		ADD PANE PARAMS
		*************************/

		function addPaneParams() {
			pane
				.addInput(PARAMS, 'edgesThickness', {
					min: 0.0,
					max: 10.0
				})
				.on('change', value => {
					edgesUniforms.u_edgesThickness.value = value;
				});

			pane
				.addInput(PARAMS, 'distRange', {
					min: 1,
					max: 32
				})
				.on('change', value => {
					makeDistortionPlanes(true);
				});

			pane
				.addInput(PARAMS, 'planeSubdiv', {
					min: 2,
					max: 32
				})
				.on('change', value => {
					makeDistortionPlanes(true);
				});

			pane
				.addInput(PARAMS, 'edgesRenderStrength', {
					min: 0.1,
					max: 24.0
				})
				.on('change', value => {
					fsQuadUniforms.edgesRenderStrength.value = value;
				});

			pane
				.addInput(PARAMS, 'chromaticAberrMod', {
					min: 0.0,
					max: 10.0
				})
				.on('change', value => {
					fsQuadUniforms.chromaticAberrMod.value = value;
				});

			// 0.3
			pane.addInput(PARAMS, 'rotateSpeed', {
				min: -0.5,
				max: 0.5,
			})
		}

		/*************************
		UPDATE BACKGROUND CANVAS
		*************************/

		function updateBgCanvas(time) {

			bgCanvasCtx.clearRect(0, 0, canvasWidth, canvasHeight);

			// border
			bgCanvasCtx.fillStyle = 'red';
			bgCanvasCtx.fillRect(0, 0, canvasWidth, canvasHeight);

			// bg
			bgCanvasCtx.fillStyle = 'white';
			bgCanvasCtx.fillRect(10, 10, canvasWidth - 20, canvasHeight - 20);

			// text
			// let fontSize = 180;
			// bgCanvasCtx.font = fontSize + 'px Oswald';
			// bgCanvasCtx.fillStyle = 'black';
			// bgCanvasCtx.textAlign = "center";
			// bgCanvasCtx.textBaseline = "middle";
			// let textMetric = bgCanvasCtx.measureText('ALL YOU SEE IS');
			// let textSnippetWidth = textMetric.width;
			// let textSnippetsPerLine = 3;
			// let textLines = Math.ceil(canvasHeight / fontSize);
			// let textLineHeight = fontSize;
			// let snippetPadding = 45;
			// let scrollSpeed = 30;

			// for (let i = 0; i < textLines; i++) {
			// 	for (let j = 0; j < textSnippetsPerLine; j++) {
			// 		let scrollDir = i % 2 === 0 ? -1 : 1;
			// 		let x = j * (textSnippetWidth + snippetPadding) + scrollSpeed * time * scrollDir;
			// 		bgCanvasCtx.fillText('ALL YOU SEE IS', x, i * textLineHeight);
			// 	}
			// }

			if (time) {
				for (let i = 0; i < textLines.length; i++) {
					textLines[i].update(time);
					textLines[i].draw();
				}
			}

		}

		/*************************
		ON WINDOW RESIZE
		*************************/

		function onWindowResize() {
			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();

			renderer.setSize(window.innerWidth, window.innerHeight);
		}

		/*************************
		ANIMATE
		*************************/

		function animate(time) {
			requestAnimationFrame(animate);

			time *= 0.001;

			updateBgCanvas(time);
			bgCanvasTexture.needsUpdate = true;

			var delta = clock.getDelta() * 0.5;

			if (distPlaneNormals) {
				distPlaneNormals.rotation.y = PARAMS.rotateSpeed * Math.sin(time);
				distPlaneEdges.rotation.y = PARAMS.rotateSpeed * Math.sin(time);
			}

			renderer.setRenderTarget(bgRenderTarget);
			renderer.render(bgRtScene, bgRtCamera);
			renderer.setRenderTarget(distortionNormalsRenderTarget);
			renderer.render(distortionNormalsScene, distortionNormalsCamera);
			renderer.setRenderTarget(distortionEdgesRenderTarget);
			renderer.render(distortionEdgesScene, distortionEdgesCamera);
			renderer.setRenderTarget(null);

			renderer.render(scene, camera);
		}
	</script>
</body>

</html>
